1. Зробити оцінку складності алгоритму за кодом

void func(int A[], int low, int high) {
  int i = low;
  int j = high;
  int x = A[(low + high) / 2]; // опорный элемент
  do {  // O(high - low + 1)
    while (A[i] < x) ++i;
    while (A[j] > x) --j;
    if (i <= j) {
      int temp = A[i];
      A[i] = A[j];
      A[j] = temp;
      i++;
      j--;
    }
  } while (i < j);
  if (low < j)  // recursion
    func(A, low, j);
  if (i < high)  // recursion
    func(A, i, high);
}

Ответ:
Выше мы видим алгоритм быстрой сортировки. 
В худшем случае сложность будет O(n^2) (Если мы каждый раз будем делать очень плохой выбор опорного элемента). 
В среднем - O(n*logn). 
В лучшем - O(n*logn).

2. Виберіть найбільш підходящий контейнер для збереження інформації телефонного довідника. Мається на увазі,
що довідник дозволяє знайти інформацію про абонента за номером. Обґрунтуйте вибір певного контейнера.
Обгрунтування передбачає приведення списку операцій, що найбільш часто застосовуються для цього
контейнера, і оцінок їх складностей по O нотації.

Ответ:
В данном случае нам лучше всего подойдут ассоциативные контейнеры типа map. 
Они могут хранить данные в формате Ключ-Значение, что нам и нужно, исходя из задания.
Стандартная библиотека C++ предоставляет нам выбор из обычного map-а, который постоен на красно-черном дереве 
и unordered_map-а, который является хеш-таблицей, построенной с помощью метода цепочек. 

Основные операции, которые нам нужно будет выполнять над контейнером:
- Добавление. Стабильный O(logn) в std::map. O(1) в среднем и O(n) в худшем случае для std::unordered_map.
- Удаление. Стабильный O(logn) в std::map. O(1) в среднем и O(n) в худшем случае для std::unordered_map.
- Поиск. Стабильный O(logn) в std::map. O(1) в среднем и O(n) в худшем случае для std::unordered_map.

Худший случай для std::unordered_map получается при возникновении коллизий. Данную ситуацию можно
списать на погрешность, так как с разными номерами телефонов мы, вероятнее всего, будем получать разные хеши.
В остальном, std::unordered_map имеет преимущество в скорости перед std::map.
Также, следует отметить, что std::map всегда хранит данные в отсортированном виде,
но в данной задаче нам это не важно, поэтому мы можем сделать выбор в пользу скорости.

Итого: 
Лучший вариант для телефонного справочника - std::unordered_map.